package moonbox.jdbc

import java.sql.{Blob, CallableStatement, Clob, DatabaseMetaData, NClob, PreparedStatement, SQLException, SQLWarning, SQLXML, Savepoint, Statement, Struct}
import java.util.Properties
import java.util.concurrent.Executor
import java.{sql, util}

import moonbox.client.JdbcClient
import moonbox.common.message.{JdbcLoginInbound, JdbcLoginOutbound, JdbcLogoutInbound, JdbcLogoutOutbound}
import org.apache.commons.codec.digest.DigestUtils

class MoonboxConnection(url: String, props: Properties) extends java.sql.Connection {

  import moonbox.util.MoonboxJDBCUtils._

  private var jdbcSession: JdbcSession = _
  var statement: MoonboxStatement = _
  var closed: Boolean = _

  def userCheck(): Boolean = {
    var flag = false
    val newProps = parseURL(url, props)
    val username = newProps.getProperty(USER_KEY)
    val pwd = newProps.getProperty(PASSWORD_KEY)
    val database = newProps.getProperty(DB_NAME)
    val table = {
      val tb = newProps.getProperty("table")
      if (tb != null) tb
      else newProps.getProperty("collection")
    }
    // TODO: Support cluster?
    // use the first host and port pair to get a JdbcClient
    val (host, port) = parseHostsAndPorts(newProps.getProperty(HOSTS_AND_PORTS)).map { case (h, p) => (h, p.toInt) }.head
    val startTime = System.currentTimeMillis()
    val client = new JdbcClient(host, port)
    client.connect()
    if (client.isConnected()) {
      val messageId = client.getMessageId()
      val resp = client.sendAndReceive(JdbcLoginInbound(messageId, username, pwd, database))
      resp match {
        case msg: JdbcLoginOutbound =>
          msg.err match {
            case Some(err) =>
              client.close()
              throw new Exception(s"Get connection error when checking username and password: $err)")
            case None =>
              flag = true
              initSession(client, database, table, username, pwd, newProps)
          }
        case e => {
          client.close()
          throw new Exception(s"Get MoonboxConnection error: $e")
        }
      }
    }
    flag
  }

  private def initSession(jdbcClient: JdbcClient, database: String, table: String, username: String, pwd: String, props: Properties): Unit = {
    if (pwd != null && pwd.length > 0)
      jdbcSession = JdbcSession(jdbcClient, database, table, username, DigestUtils.md5Hex(pwd), props)
    else
      jdbcSession = JdbcSession(jdbcClient, database, table, username, pwd, props)
    closed = false
  }

  def getSession(): JdbcSession = jdbcSession

  override def commit(): Unit = {}

  override def getHoldability: Int = 0

  override def setCatalog(catalog: String): Unit = {}

  override def setHoldability(holdability: Int): Unit = {}

  override def prepareStatement(sql: String): PreparedStatement = null

  override def prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int): PreparedStatement = null

  override def prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): PreparedStatement = null

  override def prepareStatement(sql: String, autoGeneratedKeys: Int): PreparedStatement = null

  override def prepareStatement(sql: String, columnIndexes: Array[Int]): PreparedStatement = null

  override def prepareStatement(sql: String, columnNames: Array[String]): PreparedStatement = null

  override def createClob(): Clob = null

  override def setSchema(schema: String): Unit = {}

  override def setClientInfo(name: String, value: String): Unit = {}

  override def setClientInfo(properties: Properties): Unit = {}

  override def createSQLXML(): SQLXML = null

  override def getCatalog: String = null

  override def createBlob(): Blob = null

  def checkClosed(): Unit = {
    if (jdbcSession == null)
      throw new Exception("Exception while create a statement, because the JdbcSession is null value")
    else if (isClosed)
      throw new Exception("Exception while create a statement, because the connection is already closed.")
  }

  override def createStatement(): Statement = {
    checkClosed()
    statement = new MoonboxStatement(this)
    statement
  }

  override def createStatement(resultSetType: Int, resultSetConcurrency: Int): Statement = createStatement() // TODO: createStatement(resultSetType: Int, resultSetConcurrency: Int)

  override def createStatement(resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): Statement = createStatement() // TODO: createStatement(resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int)

  override def abort(executor: Executor): Unit = {} // TODO: abort

  override def setAutoCommit(autoCommit: Boolean): Unit = {} // TODO: setAutoCommit

  override def getMetaData: DatabaseMetaData = null // TODO: getMetaData: DatabaseMetaData

  override def setReadOnly(readOnly: Boolean): Unit = {} // TODO: setReadOnly

  override def prepareCall(sql: String): CallableStatement = null

  override def prepareCall(sql: String, resultSetType: Int, resultSetConcurrency: Int): CallableStatement = null

  override def prepareCall(sql: String, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): CallableStatement = null

  override def setTransactionIsolation(level: Int): Unit = {}

  override def getWarnings: SQLWarning = null

  override def releaseSavepoint(savepoint: Savepoint): Unit = {}

  override def nativeSQL(sql: String): String = null

  override def isReadOnly: Boolean = true

  override def createArrayOf(typeName: String, elements: Array[AnyRef]): sql.Array = null

  override def setSavepoint(): Savepoint = null

  override def setSavepoint(name: String): Savepoint = null

  private def closeSession(jdbcSession: JdbcSession): Unit = {
    val messageId = jdbcSession.jdbcClient.getMessageId()
    val resp = jdbcSession.jdbcClient.sendAndReceive(JdbcLogoutInbound(messageId, jdbcSession.user))
    resp match {
      case r: JdbcLogoutOutbound =>
        if (r.err.isDefined) {
          throw new Exception(s"Jdbc connection close error: ${r.err.get}")
        } else {
          jdbcSession.jdbcClient.close()
          jdbcSession.closed = true
        }
      case other => throw new SQLException(s"Jdbc connection close error: $other")
    }
  }

  override def close(): Unit = {
    if (statement != null && !statement.isClosed) {
      statement.close()
    }
    statement = null
    closeSession(jdbcSession)
    if (jdbcSession != null && !jdbcSession.closed) {
      jdbcSession.jdbcClient.close()
      jdbcSession.closed = true
    }
    jdbcSession = null
    closed = true
  }

  override def createNClob(): NClob = null

  override def rollback(): Unit = {}

  override def rollback(savepoint: Savepoint): Unit = {}

  override def setNetworkTimeout(executor: Executor, milliseconds: Int): Unit = throw new SQLException("unsupported")

  override def setTypeMap(map: util.Map[String, Class[_]]): Unit = {}

  override def isValid(timeout: Int): Boolean = if (jdbcSession == null || isClosed) false else true

  override def getAutoCommit: Boolean = false

  override def clearWarnings(): Unit = {}

  override def getSchema: String = null

  override def getNetworkTimeout: Int = throw new SQLException("unsupported")

  override def isClosed: Boolean = closed

  override def getTransactionIsolation: Int = 0

  override def createStruct(typeName: String, attributes: Array[AnyRef]): Struct = null

  override def getClientInfo(name: String): String = null

  override def getClientInfo: Properties = null

  override def getTypeMap: util.Map[String, Class[_]] = null

  override def unwrap[T](iface: Class[T]): T = {
    if (isWrapperFor(iface))
      this.asInstanceOf[T]
    else
      throw new SQLException("unwrap exception")
  }

  override def isWrapperFor(iface: Class[_]): Boolean = iface != null && iface.isAssignableFrom(getClass)
}
