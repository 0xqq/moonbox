package moonbox.jdbc

import java.sql.{Blob, CallableStatement, Clob, DatabaseMetaData, NClob, PreparedStatement, SQLException, SQLWarning, SQLXML, Savepoint, Statement, Struct}
import java.util.Properties
import java.util.concurrent.Executor
import java.{sql, util}

import moonbox.client.JdbcClient
import moonbox.common.message.{JdbcLoginInbound, JdbcLoginOutbound, JdbcLogoutInbound, JdbcLogoutOutbound}
import org.apache.commons.codec.digest.DigestUtils

class MoonboxConnection(url: String, props: Properties) extends java.sql.Connection {

  import moonbox.util.MoonboxJDBCUtils._

  private var jdbcSession: JdbcSession = _
  var statement: MoonboxStatement = _
  var closed: Boolean = _
  var database: String = _
  def userCheck(): Boolean = {
    var flag = false
    val newProps = parseURL(url, props)
    val username = newProps.getProperty(USER_KEY)
    val pwd = newProps.getProperty(PASSWORD_KEY)
    database = newProps.getProperty(DB_NAME)
    val table = {
      val tb = newProps.getProperty("table")
      if (tb != null) tb
      else newProps.getProperty("collection")
    }
    // TODO: Support cluster?
    // use the first host and port pair to get a JdbcClient
    val (host, port) = parseHostsAndPorts(newProps.getProperty(HOSTS_AND_PORTS)).map { case (h, p) => (h, p.toInt) }.head
    val client = new JdbcClient(host, port)
    client.connect()
    if (client.isConnected()) {
      val messageId = client.getMessageId()
      val resp = client.sendAndReceive(JdbcLoginInbound(messageId, username, pwd, database))
      resp match {
        case msg: JdbcLoginOutbound =>
          msg.err match {
            case Some(err) =>
              client.close()
              throw new SQLException(s"Get connection error when checking username and password: $err)")
            case None =>
              flag = true
              initSession(client, database, table, username, pwd, newProps)
          }
        case e => {
          client.close()
          throw new SQLException(s"Get MoonboxConnection error: $e")
        }
      }
    }
    flag
  }

  private def initSession(jdbcClient: JdbcClient, database: String, table: String, username: String, pwd: String, props: Properties): Unit = {
    if (pwd != null && pwd.length > 0)
      jdbcSession = JdbcSession(jdbcClient, database, table, username, DigestUtils.md5Hex(pwd), props)
    else
      jdbcSession = JdbcSession(jdbcClient, database, table, username, pwd, props)
    closed = false
  }

  def getSession(): JdbcSession = jdbcSession

//  override def commit(): Unit = ???

  override def commit(): Unit = ???

  override def getHoldability: Int = ???

  override def setCatalog(catalog: String): Unit = ???

  override def setHoldability(holdability: Int): Unit = ???

  override def prepareStatement(sql: String): PreparedStatement = ???

  override def prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int): PreparedStatement = ???

  override def prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): PreparedStatement = ???

  override def prepareStatement(sql: String, autoGeneratedKeys: Int): PreparedStatement = ???

  override def prepareStatement(sql: String, columnIndexes: Array[Int]): PreparedStatement = ???

  override def prepareStatement(sql: String, columnNames: Array[String]): PreparedStatement = ???

  override def createClob(): Clob = ???

  override def setSchema(schema: String): Unit = ???

  override def setClientInfo(name: String, value: String): Unit = ???

  override def setClientInfo(properties: Properties): Unit = ???

  override def createSQLXML(): SQLXML = ???

  override def getCatalog: String = database

  override def createBlob(): Blob = ???

  def checkClosed(): Unit = {
    if (jdbcSession == null)
      throw new SQLException("Exception while create a statement, because the JdbcSession is null value")
    else if (isClosed)
      throw new SQLException("Exception while create a statement, because the connection is already closed.")
  }

  override def createStatement(): Statement = {
    checkClosed()
    statement = new MoonboxStatement(this)
    statement
  }

  override def createStatement(resultSetType: Int, resultSetConcurrency: Int): Statement = createStatement() // TODO: createStatement(resultSetType: Int, resultSetConcurrency: Int)

  override def createStatement(resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): Statement = createStatement() // TODO: createStatement(resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int)

  override def abort(executor: Executor): Unit = this.close() // TODO: abort

  override def setAutoCommit(autoCommit: Boolean): Unit = ??? // TODO: setAutoCommit

  override def getMetaData: DatabaseMetaData = ??? // TODO: getMetaData: DatabaseMetaData

  override def setReadOnly(readOnly: Boolean): Unit = ??? // TODO: setReadOnly

  override def prepareCall(sql: String): CallableStatement = ???

  override def prepareCall(sql: String, resultSetType: Int, resultSetConcurrency: Int): CallableStatement = ???

  override def prepareCall(sql: String, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): CallableStatement = ???

  override def setTransactionIsolation(level: Int): Unit = ???



//  private def closeSession(jdbcSession: JdbcSession): Unit = {
//    val messageId = jdbcSession.jdbcClient.getMessageId()
//    val resp = jdbcSession.jdbcClient.sendAndReceive(JdbcLogoutInbound(messageId))
//    resp match {
//      case r: JdbcLogoutOutbound =>
//        if (r.err.isDefined) {
//          throw new SQLException(s"Jdbc connection close error: ${r.err.get}")
//        } else {
//          jdbcSession.jdbcClient.close()
//          jdbcSession.closed = true
//        }
//      case other => throw new SQLException(s"Jdbc connection close error: $other")
//    }
//  }

  override def getWarnings: SQLWarning = ???

  override def releaseSavepoint(savepoint: Savepoint): Unit = ???

  override def nativeSQL(sql: String): String = ???

  override def isReadOnly: Boolean = ???

  override def createArrayOf(typeName: String, elements: Array[AnyRef]): sql.Array = ???

  override def setSavepoint(): Savepoint = ???

  override def setSavepoint(name: String): Savepoint = ???

  override def close(): Unit = {
    if (statement != null && !statement.isClosed) {
      statement.close()
    }
    statement = null
//    closeSession(jdbcSession)
    if (jdbcSession != null && !jdbcSession.closed) {
      jdbcSession.jdbcClient.close()
      jdbcSession.closed = true
    }
    jdbcSession = null
    closed = true
  }

  override def createNClob(): NClob = ???

  override def rollback(): Unit = ???

  override def rollback(savepoint: Savepoint): Unit = ???

  override def setNetworkTimeout(executor: Executor, milliseconds: Int): Unit = throw new SQLException("unsupported")

  override def setTypeMap(map: util.Map[String, Class[_]]): Unit = ???

  override def isValid(timeout: Int): Boolean = if (jdbcSession == null || isClosed) false else true

  override def getAutoCommit: Boolean = ???

  override def clearWarnings(): Unit = ???

  override def getSchema: String = ???

  override def getNetworkTimeout: Int = throw new SQLException("unsupported")

  override def isClosed: Boolean = closed

  override def getTransactionIsolation: Int = ???

  override def createStruct(typeName: String, attributes: Array[AnyRef]): Struct = ???

  override def getClientInfo(name: String): String = ???

  override def getClientInfo: Properties = ???

  override def getTypeMap: util.Map[String, Class[_]] = ???

  override def unwrap[T](iface: Class[T]): T = {
    if (isWrapperFor(iface))
      this.asInstanceOf[T]
    else
      throw new SQLException("unwrap exception")
  }

  override def isWrapperFor(iface: Class[_]): Boolean = iface != null && iface.isAssignableFrom(getClass)
}
